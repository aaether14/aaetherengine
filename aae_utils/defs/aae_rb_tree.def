/**
---aae_rb_tree.def - Dinescu Stefan-Cristian aka Aaether - 10.12.2016
----------------------------------------------------------------------
Code generation for red/black tree with TYPE keys
-don't ever use variables, functions etc. starting with "__". Only the framework has this right.
AAE_RB_TREE_KEY_TYPE must be defined
AAE_RB_TREE_VALUE_TYPE may be defined for key/value pairs
AAE_RB_TREE_VALUE_IDENTITY should be defined if AAE_RB_TREE_VALUE_TYPE is defined
AAE_RB_TREE_MEMORY_ARENA must de defined - see aae_allocators.h for further reference
Features:
-insert nodes
Safe types:
-aae_RBTree(TYPE)
-aae_RBTreeNode(TYPE)
**/



#ifndef AAE_RB_TREE_DEF
#define AAE_RB_TREE_DEF
#include "aae_defines.h"
#include "aae_types.h"
#include "aae_memory_allocator.h"
#include "error/aae_error.h"



template <typename TREE, typename NODE>
void __rb_tree_left_rotate(TREE * t, NODE * x)
{
	
	
	if (!t || !x)
		return;


	NODE * y = x->right;
	x->right = y->left;


	if (y->left != t->m_nil)
		y->left->parent = x;


	y->parent = x->parent;
	if (x->parent == t->m_nil)
		t->m_root = y;
	else
	{

		if (x == x->parent->left)
			x->parent->left = y;
		else
			x->parent->right = y;
	}


	y->left = x;
	x->parent = y;

}



template <typename TREE, typename NODE>
void __rb_tree_right_rotate(TREE * t, NODE * y)
{


	if (!t || !y)
		return;


	NODE * x = y->left;
	y->left = x->right;



	if (x->right != t->m_nil)
		x->right->parent = y;


	x->parent = y->parent;
	if (y->parent == t->m_nil) 
		t->m_root = x;
	else
	{
		if (y == y->parent->left)
			y->parent->left = x;
		else
			y->parent->right = x;
	}


	x->right = y;
	y->parent = x;

}
#endif /** AAE_RB_TREE_DEF **/



#ifndef AAE_RB_TREE_KEY_TYPE
#error "Must define AAE_RB_TREE_KEY_TYPE!"
#endif



#ifndef AAE_RB_TREE_MEMORY_ARENA
#error "Must define AAE_RB_TREE_MEMORY_ARENA!"
#endif



#ifndef AAE_RB_TREE_VALUE_IDENTITY
#define AAE_RB_TREE_VALUE_IDENTITY AAE_NULL
#endif


/**
*Indirection is used in order to achieve defined token concatenation
*/
#define __AAE_RB_TREE(NAME) INDIRECT_TOKENPASTE(INDIRECT_TOKENPASTE(__rb_tree, NAME), AAE_RB_TREE_KEY_TYPE)
#ifdef AAE_RB_TREE_VALUE_TYPE
#define AAE_RB_TREE_NAME INDIRECT_TOKENPASTE(_, AAE_RB_TREE_VALUE_TYPE)
#else
#define AAE_RB_TREE_NAME _
#endif




struct __AAE_RB_TREE(AAE_RB_TREE_NAME) /* __rb_tree_##AAE_RB_TREE_KEY_TYPE -eg. __rb_tree_float */
{


	struct __node /** a red/black node **/
	{	
		enum {black, red} color;
		AAE_RB_TREE_KEY_TYPE key;
		#ifdef AAE_RB_TREE_VALUE_TYPE
		AAE_RB_TREE_VALUE_TYPE value;
		#endif
		__node *parent, *left, *right;
	} *m_root, *m_nil;



	__AAE_RB_TREE(AAE_RB_TREE_NAME)()
	{

		aae_set_error(0); /** no error at first **/
		m_nil = AAE_NEW(__node, AAE_RB_TREE_MEMORY_ARENA);

		if (m_nil != AAE_NULL)
		{
			m_nil->parent = m_nil->left = m_nil->right = m_nil;
			m_nil->color = __node::black;
			m_root = m_nil;
		}
		else
			aae_set_error(15);

	}


	#ifdef AAE_RB_TREE_VALUE_TYPE
	void insert(AAE_RB_TREE_KEY_TYPE key, AAE_RB_TREE_VALUE_TYPE value)
	#else
	void insert(AAE_RB_TREE_KEY_TYPE key)
	#endif
	{

		aae_set_error(0); /** no error at first **/
 		#ifdef AAE_RB_TREE_VALUE_TYPE
		__node * new_node = __internal_insert_bst(m_nil, m_root, key, value);
		#else
		__node * new_node = __internal_insert_bst(m_nil, m_root, key);
		#endif
		if (!new_node) return;
		new_node->color = __node::red;



		while (new_node->parent->color == __node::red)
		{


			if (new_node->parent == new_node->parent->parent->left)
			{


				__node * right_uncle = new_node->parent->parent->right;
				if (right_uncle->color == __node::red)
				{

					right_uncle->color = __node::black;
					new_node->parent->color = __node::black;
					new_node->parent->parent->color = __node::red;
					new_node = new_node->parent->parent;

				}
				else
				{

					if (new_node == new_node->parent->right)
					{

						new_node = new_node->parent;
						__rb_tree_left_rotate(this, new_node);
					}
					
					new_node->parent->color = __node::black;
					new_node->parent->parent->color = __node::red;
					__rb_tree_right_rotate(this, new_node->parent->parent);

				}

			}
			else
			{

				__node * left_uncle = new_node->parent->parent->left;
				if (left_uncle->color == __node::red)
				{

					left_uncle->color = __node::black;
					new_node->parent->color = __node::black;
					new_node->parent->parent->color = __node::red;
					new_node = new_node->parent->parent;

				}
				else
				{

					if (new_node == new_node->parent->left)
					{

						new_node = new_node->parent;
						__rb_tree_right_rotate(this, new_node);
					}
					
					new_node->parent->color = __node::black;
					new_node->parent->parent->color = __node::red;
					__rb_tree_left_rotate(this, new_node->parent->parent);

				}

				

			}

		}
		m_root->color = __node::black;


	}


	#ifdef AAE_RB_TREE_VALUE_TYPE
	AAE_RB_TREE_VALUE_TYPE __internal_get(__node * current_node, AAE_RB_TREE_KEY_TYPE key)
	{

		if (current_node->key == key)
			return current_node->value;
		else if (key < current_node->key && current_node->left != m_nil)
			return __internal_get(current_node->left, key);
		else if (key > current_node->key && current_node->right != m_nil)
			return __internal_get(current_node->right, key);
		else
			return AAE_RB_TREE_VALUE_IDENTITY;

	}
	AAE_RB_TREE_VALUE_TYPE get(AAE_RB_TREE_KEY_TYPE key)
	{
		return __internal_get(m_root, key);
	}
	#endif


	#ifdef AAE_RB_TREE_VALUE_TYPE
	__node* __internal_insert_bst(__node * parent, __node *&root, 
					AAE_RB_TREE_KEY_TYPE key, 
					AAE_RB_TREE_VALUE_TYPE value)
	#else
	__node* __internal_insert_bst(__node * parent, __node *&root,
					AAE_RB_TREE_KEY_TYPE key)
	#endif
	{ 


		if (!parent || !root)
			return AAE_NULL;



		if (root == m_nil)
		{
			
			root = AAE_NEW(__node, AAE_RB_TREE_MEMORY_ARENA);
			if (root == AAE_NULL) return AAE_NULL;
			root->key = key;
			#ifdef AAE_RB_TREE_VALUE_TYPE
			root->value = value;
			#endif
			root->left = root->right = m_nil;
			root->parent = parent;
			return root;

		}
		else
		{

			if (key < root->key)
			#ifdef AAE_RB_TREE_VALUE_TYPE /** ------------------------ **/
				return __internal_insert_bst(root, root->left, key, value);
			else
				return __internal_insert_bst(root, root->right, key, value);
			#else /** ----------------------------------------- **/
				return __internal_insert_bst(root, root->left, key);
			else
				return __internal_insert_bst(root, root->right, key);
			#endif /** ------------------------ **/

		}
	

	}


};




/**
*Types
**/
#define aae_RBTree(TYPE, VALUE)					__rb_tree_##VALUE##TYPE
#define aae_RBTreeNode(TYPE, VALUE)				__rb_tree_##VALUE##TYPE::__node



/**
*Undefine defines
**/
#ifdef AAE_RB_TREE_NAME
#undef AAE_RB_TREE_NAME
#endif

#ifdef AAE_RB_TREE_KEY_TYPE
#undef AAE_RB_TREE_KEY_TYPE
#endif

#ifdef AAE_RB_TREE_VALUE_TYPE
#undef AAE_RB_TREE_VALUE_TYPE
#endif

#ifdef AAE_RB_TREE_VALUE_IDENTITY
#undef AAE_RB_TREE_VALUE_IDENTITY
#endif

#ifdef AAE_RB_TREE_MEMORY_ARENA
#undef AAE_RB_TREE_MEMORY_ARENA
#endif
